<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[题解 luoguP2303 【[SDOi2012]Longge的问题】]]></title>
    <url>%2F2019%2F04%2F08%2F%E9%A2%98%E8%A7%A3%20luoguP2303%20%E3%80%90%5BSDOi2012%5DLongge%E7%9A%84%E9%97%AE%E9%A2%98%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 好水的蓝题啊，少数没有看题解做的题 题面简洁明了：求$\sum\limits_{i=1}^{n}gcd(i,n)$ 设$gcd(i,n)=d$，则$gcd(i/d,n/d)=1$ $d$显然就是$n$的因数 我们对于每个$d$，要求有多少$i$使得$gcd(i/d,n/d)=1$，设求出有$x$个$i$，那么对答案的贡献就是$d \times x$。为什么是这些贡献？很显然，这些$i$与$n$的$gcd$就是$d$，共$x$个这样的$i$，所以是$d \times x$。 因为满足$gcd(i/d,n/d)=$1的$i/d$的个数就是与$n/d$互质的数，每个$i/d$又对应一个$i$，个数就是$φ(n/d)$。前面说了$d$是$n$的因数，我们枚举所有因数，累加答案即可。 对于每个$φ(n/d)$，$\sqrt{n}$求即可。 代码：12345678910111213141516171819202122232425262728293031323334353637#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define oo (1e18)#define int long long#define LL unsigned long long#define hh puts("")using namespace std;int ans,n;inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-1;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline int getphi(int x)&#123; int res=x; for(int i=2;i*i&lt;=x;i++)&#123; if(x%i==0)&#123; res=res/i*(i-1); while(x%i==0) x/=i; &#125; &#125; if(x&gt;1) res=res/x*(x-1); return res;&#125;signed main()&#123; n=read(); int sq=sqrt(n); for(int i=1;i&lt;=sq;i++)&#123; if(n%i==0)&#123; ans+=getphi(n/i)*i; if(i*i!=n) ans+=getphi(i)*(n/i); &#125; &#125; printf("%lld",ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>数论</tag>
        <tag>欧拉函数</tag>
        <tag>Luogu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP3200 【[HNOI2009]有趣的数列】]]></title>
    <url>%2F2019%2F04%2F01%2F%E9%A2%98%E8%A7%A3%20luoguP3200%20%E3%80%90%5BHNOI2009%5D%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%B0%E5%88%97%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 很好的一道思维题。警告：文字较多，没有耐心者勿入。 首先我们命名$a1,a_3,…,a{2n-1}$为奇数位，其余为偶数位。观察题目条件：奇数位与偶数位上的数字都满足从左到右递增，相邻的$a{2i-1},a{2i}$满足$a{2i-1}&lt;a{2i}$。 首先很容易发现，一个偶数位上的数，比它左边的所有偶数位上的数要大，每个偶数位上的数又比它左相邻奇数位上的数要大。这两条信息，我们可以得出，一个偶数位上的数比它左边所有数都要大，那么再概括一下，就是一个偶数位上的数，大于等于这个偶数位的下标。 这个结论并不够我们来得出最后的答案，我们还需要一些结论。 因为数字从左到右，无论奇数位偶数位都满足递增，那么，我们考虑假如我们按$1-2n$的顺序一个一个放数字，我们应该放在哪里？ 很容易发现，我们应该放在最靠左的能放的奇数位或者偶数位上，这样才能保证满足递增。 那还有什么限制呢？我们设已经放了$1-x$的数，$x_1$个放在了奇数位上，$x_2$个放在了偶数位上$(x_1+x_2=x)$。我们想起前面得出的关于偶数位上放数的结论：一个偶数位上的数，大于等于这个偶数位的下标。那什么时候会小于呢？猜想+估摸一下，感觉是$x_2&gt;x_1$？？ 猜想是很**的，作为一个严谨的人，让我们来简单的证一下。 反证： 假设当前情况为$x_2&gt;x_1$，那么显然$x_2&gt;x/2$，同时最后一个偶数位的下标是$2\times x_2$。 因为我们总共只有$x$个数，但由$x_2&gt;x/2$我们得知，$2\times x_2&gt;x$，所以最后一个偶数位不管放什么，都不满足条件，假设不成立。 所以得出结论，按从小到大的顺序放到任意一个数$x$，都满足放在偶数位上的数字个数小于等于放在奇数位上的数字个数。 想到什么？This 这不是完全一样的卡特兰数吗？但这道题好像更麻烦一点，模数不是质数。那么就需要一些求卡特兰数的技巧，参考别的题解即可，几乎都讲了。 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define oo (1e18)#define int long long#define LL unsigned long long#define hh puts("")using namespace std;int n,mo,cnt[2000005],pr[2000005],mn[2000005],top,ans=1;bool v[2000005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline int ksm(int x,int y)&#123; int res=1; while(y)&#123; if(y&amp;1) res=res*x%mo; y&gt;&gt;=1; x=x*x%mo; &#125; return res;&#125;signed main()&#123; n=read(),mo=read(); memset(v,1,sizeof(v)); v[1]=0; for(int i=2;i&lt;=2*n;i++)&#123; if(v[i])&#123; pr[++top]=i; mn[i]=i; &#125; for(int j=1;j&lt;=top&amp;&amp;pr[j]*i&lt;=2*n;j++)&#123; v[pr[j]*i]=0; if(i%pr[j]==0) break; mn[pr[j]*i]=pr[j]; &#125; &#125; for(int i=1;i&lt;=n;i++) cnt[i]=-1; for(int i=n+2;i&lt;=2*n;i++) cnt[i]=1; for(int i=2*n;i&gt;=2;i--)&#123; if(mn[i]&lt;i)&#123; cnt[mn[i]]+=cnt[i]; cnt[i/mn[i]]+=cnt[i]; &#125; &#125; for(int i=2;i&lt;=2*n;i++) if(mn[i]==i) ans=ans*ksm(i,cnt[i])%mo; printf("%lld",ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>数论</tag>
        <tag>Luogu</tag>
        <tag>卡特兰数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP4397 【[JLOI2014]聪明的燕姿】]]></title>
    <url>%2F2019%2F03%2F29%2F%E9%A2%98%E8%A7%A3%20luoguP4397%20%E3%80%90%5BJLOI2014%5D%E8%81%AA%E6%98%8E%E7%9A%84%E7%87%95%E5%A7%BF%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 给你一个数$S$，求约数和等于$S$的数。 好像也没什么好说的，主要就两个式子： 1、整数的唯一分解定理 2、一个数的所有约数和 然后发现枚举选了哪些质数，以及这些质数的指数，等于得到了$x$，判断$S$是否符合条件即可。暴力枚举肯定会$T$，那就搜索，因为搜索可以在条件满足时再进入下一层，效率肯定大于枚举。 搜索需要三个参数，$now$，$x$，$s$，分别表示：还剩多少能够分解，当前枚举第$x$个质数，当前是哪个数。 我们知道，搜索满足条件时，就可以得到答案。那么，什么叫满足条件？有两种： 1、若当前数$now$可表示成一个并未搜索过的质数与$1$的和$($设这个质数为$p$，其实就是$p^{0}+p^{1}$ $)$，则$s$与$p$的乘积可以成为答案。 $update$：为什么要这样判？因为我们要处理的数$S$是一个大整数，最大为$2\times 1e9$，显然如果它是一个特别大的质数和另一个数的乘积，我们是无法搜索到那个特别大的质数的，筛的时候也筛不到。但我们知道，对于一个数$S$，大于$\sqrt{S}$的质因数最多只有一个。所以我们分解$S$的时候，只要处理小于等于$\sqrt{S}$的那部分，然后判断剩下的是不是个大质数即可。 2、$now=1$，即当前的数不能再分解。则当前的数$s$可以成为答案。 主要的核心还是搜索，写了注释便于理解：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define oo (1e18)#define int long long#define LL unsigned long long#define hh puts("")using namespace std;int pr[100005],top=0,ans[100005],cnt;bool v[100005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline bool pd(int x)&#123; if(x==1) return 0; for(int i=2;i*i&lt;=x;i++) if(x%i==0) return 0; return 1;&#125;void dfs(int now, int x, int s)&#123;// 还剩多少能够分解 第x个质数 当前是哪个数 if(now==1)&#123; ans[++cnt]=s; return; &#125; if(pd(now-1)&amp;&amp;now&gt;pr[x]) ans[++cnt]=s*(now-1); for(int i=x;pr[i]*pr[i]&lt;=now;i++)&#123;//枚举下一个选哪个质数 int t=pr[i];//t为次方和的最后一个数 int sum=pr[i]+1;//sum为总次方和 for(;sum&lt;=now;t*=pr[i],sum+=t) if(now%sum==0) dfs(now/sum,i+1,s*t); &#125;&#125;signed main()&#123; memset(v,1,sizeof(v)); v[1]=0; for(int i=2;i&lt;=100000;i++)&#123; if(v[i]) pr[++top]=i; for(int j=1;j&lt;=top&amp;&amp;pr[j]*i&lt;=100000;j++)&#123; v[i*pr[j]]=0; if(i%pr[j]==0) break; &#125; &#125; int x; while(scanf("%lld",&amp;x)!=EOF)&#123; cnt=0; dfs(x,1,1); sort(ans+1,ans+cnt+1); printf("%lld\n",cnt); for(int i=1;i&lt;=cnt;i++) printf("%lld ",ans[i]); if(cnt) hh; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>数论</tag>
        <tag>Luogu</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP1345 【[USACO5.4]奶牛的电信Telecowmunication】]]></title>
    <url>%2F2019%2F03%2F27%2F%E9%A2%98%E8%A7%A3%20luoguP1345%20%E3%80%90%5BUSACO5.4%5D%E5%A5%B6%E7%89%9B%E7%9A%84%E7%94%B5%E4%BF%A1Telecowmunication%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 众所周知，网络流可以求最小割，但割的是割边。本题一眼看就可以知道，题意要求割掉最少的点使起点到终点不连通。 最小割怎么处理点呢？我们想，只要把点取不取转化到边权就好办了。 考虑拆点，把一个点$i$拆成$i$和$i+n$。$i$向$i+n$连一条边权为$1$的边，再把连向这个点的边都连到$i$上，这个点连向其他点的边都连到$i+n$上。那么只要割掉这条边权为$1$的边，就等价于把这个点给割掉了。建完图后就是求最小割的模板了。注意起点是$st+n$而不是$st$。 总的来说，网络流几乎没有裸题，都需要动脑子(看题解)去建图。拆点就是一种比较常见的方法。 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define lowbit(x) (x)&amp;(-x)#define oo (1e18)#define ll long long#define LL unsigned long long#define hh puts("")using namespace std;int n,m,cnt=1,tot,ans,st,ed,head[10005],cur[10005],d[10005];struct Edge&#123; int v,nx,s;&#125;e[2000005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline void add(int x,int y,int z)&#123; e[++cnt].v=y; e[cnt].s=z; e[cnt].nx=head[x]; head[x]=cnt;&#125;inline bool bfs()&#123; for(int i=0;i&lt;=10000;i++) d[i]=0,cur[i]=head[i]; d[st]=1; queue&lt;int&gt; q; q.push(st); while(!q.empty())&#123; int now=q.front(); q.pop(); for(int i=head[now];i;i=e[i].nx)&#123; int v=e[i].v; if(e[i].s&amp;&amp;!d[v])&#123; d[v]=d[now]+1; if(v==ed) return 1; q.push(v); &#125; &#125; &#125; return 0;&#125;int dfs(int now,int ma)&#123; if(now==ed)&#123; ans+=ma; return ma; &#125; int used=0,t; for(int i=cur[now];i;i=e[i].nx)&#123; cur[now]=i; int v=e[i].v; if(e[i].s&amp;&amp;d[v]==d[now]+1)&#123; if(t!=dfs(v,min(e[i].s,ma-used)))&#123; used+=t; e[i].s-=t; e[i^1].s+=t; if(used==ma) break; &#125; &#125; &#125; return used;&#125;signed main()&#123; n=read(),m=read(); st=read()+n,ed=read(); for(int i=1;i&lt;=n;i++)&#123; add(i,i+n,1); add(i+n,i,0); &#125; for(int i=1;i&lt;=m;i++)&#123; int x=read(),y=read(); add(x+n,y,1e9); add(y,x+n,0); add(y+n,x,1e9); add(x,y+n,0); &#125; while(bfs()) dfs(st,1e9); printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>网络流</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 BZOJ4260 【Codechef REBXOR】]]></title>
    <url>%2F2019%2F03%2F27%2F%E9%A2%98%E8%A7%A3%20BZOJ4260%20%E3%80%90Codechef%20REBXOR%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 题目要求一个序列中的两个子段，使这两个子段每段的异或和加起来值最大。 说到异或，我就想到开花$Trie$字典树。 先考虑怎么求一个$l$到$r$子段的异或和$($异或和：所有数异或起来的值$)$： $al\oplus a{l+1}\oplus…\oplus a{r-1} \oplus a{r}=(a1\oplus a_2\oplus…\oplus a{r-1} \oplus a{r})\oplus(a_1\oplus a_2\oplus…\oplus a{l-2} \oplus a_{l-1})$ 所以处理出异或前缀和，不断加入$01Trie$树求解即可。 考虑到要求两个子段，用$ls[i],rs[i]$分别表示$1-i$的最大异或子段，$i-n$的最大异或子段。最后扫一遍取$max$即可。代码不长：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define lowbit(x) (x)&amp;(-x)#define oo (1e18)#define ll long long#define LL unsigned long longusing namespace std;int n,a[400005],s[400005],ls[400005],rs[400005],ch[12500000][2],cnt;inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-1;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline void insert(int x)&#123; int now=0; for(int i=30;i&gt;=0;i--)&#123; int t=(x&amp;(1&lt;&lt;i))?1:0; if(!ch[now][t]) ch[now][t]=++cnt; now=ch[now][t]; &#125;&#125;inline int find(int x)&#123; int now=0,res=0; for(int i=30;i&gt;=0;i--)&#123; int t=(x&amp;(1&lt;&lt;i))?0:1; if(ch[now][t])&#123; now=ch[now][t]; res+=(1&lt;&lt;i); &#125; else now=ch[now][!t]; &#125; return res;&#125;signed main()&#123; n=read(); for(int i=1;i&lt;=n;i++) a[i]=read(); ls[1]=a[1]; insert(a[1]); for(int i=2;i&lt;=n;i++)&#123; ls[i]=max(ls[i-1],find(a[i])); insert(a[i]); &#125; memset(ch,0,sizeof(ch)); cnt=0; rs[n]=a[n]; insert(a[n]); for(int i=n-1;i&gt;=2;i--)&#123; rs[i]=max(rs[i+1],find(a[i])); insert(a[i]); &#125; int ans=0; for(int i=1;i&lt;=n-1;i++) ans=max(ans,ls[i]+rs[i+1]); printf("%d",ans); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>BZOJ</tag>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP1344 【[USACO4.4]追查坏牛奶Pollutant Control】]]></title>
    <url>%2F2019%2F03%2F27%2F%E9%A2%98%E8%A7%A3%20luoguP1344%20%E3%80%90%5BUSACO4.4%5D%E8%BF%BD%E6%9F%A5%E5%9D%8F%E7%89%9B%E5%A5%B6Pollutant%20Control%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 这是一道很好的套路题。助你掌握新套路。 第一问太愚蠢了，求最小割，学过网络流应该都会。 重点是第二问，求最小割割的最少边数。太难了，默默打开题解，$get$到新套路。 建图时，我们将边的权值乘以$(($一个较大的数$a)+1)$，设新的图的最小割为$newans$，那么原图最小割为$newans/a$，最小割割的最少边数为$newans\%a$。 原理(摘自题解)：因为最小割的边集$E={w_1,w_2…w_n}$中有 w_1+w_2+w_3…+w_n=ans其中$ans$为本来的最小割。 所以必然有： w_1\times a+w_2\times a+w_3\times a…+w_n\times a=ans\times a于是又有： w1\times a+1+w2\times a+1+w3\times a+1…+wn\times a+1=ans\times a+k$k$为最小割的边数，$k&lt;=m&lt;=1000$ 最后得到结论：原图最小割为$newans/a$，最小割割的最少边数为$newans\%a$。 于是这题就解决了：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define lowbit(x) (x)&amp;(-x)#define oo (1e18)#define int long long#define LL unsigned long long#define hh puts("")using namespace std;int n,m,cnt=1,tot,ans,st,ed,head[10005],cur[10005],d[10005],base=2003;struct Edge&#123; int v,nx,s;&#125;e[2000005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline void add(int x,int y,int z)&#123; e[++cnt].v=y; e[cnt].s=z; e[cnt].nx=head[x]; head[x]=cnt;&#125;inline bool bfs()&#123; for(int i=0;i&lt;=ed;i++) d[i]=0,cur[i]=head[i]; d[st]=1; queue&lt;int&gt; q; q.push(st); while(!q.empty())&#123; int now=q.front(); q.pop(); for(int i=head[now];i;i=e[i].nx)&#123; int v=e[i].v; if(e[i].s&amp;&amp;!d[v])&#123; d[v]=d[now]+1; if(v==ed) return 1; q.push(v); &#125; &#125; &#125; return 0;&#125;int dfs(int now,int ma)&#123; if(now==ed)&#123; ans+=ma; return ma; &#125; int used=0,t; for(int i=cur[now];i;i=e[i].nx)&#123; cur[now]=i; int v=e[i].v; if(e[i].s&amp;&amp;d[v]==d[now]+1)&#123; if(t=dfs(v,min(e[i].s,ma-used)))&#123; used+=t; e[i].s-=t; e[i^1].s+=t; if(used==ma) break; &#125; &#125; &#125; return used;&#125;signed main()&#123; n=read(),m=read(); st=1,ed=n; for(int i=1;i&lt;=m;i++)&#123; int x=read(),y=read(),z=read(); add(x,y,z*base+1),add(y,x,0); &#125; while(bfs()) dfs(st,1e16); printf("%lld %lld",ans/base,ans%base); return 0;&#125; 拓展一下，也就是原题$($这题简化过$)$：我们求出了边的数量，但如果要求这些边的编号，又应该怎么做？ 参考了这篇博客： 首先，网络流的核心是从起点通过多条路径到终点，那么，我们可以想出，这每一条合格$($可以从起点流向终点$)$的路径，一定会有其中一条或多条边满流了，那么就代表这条边是这条路径的核心，去掉这条边，整张图的完整流量就会减去这条边的流量，我们称这些边为贡献边。 那么，在最小割所求的最小容量中所割掉的边的集合中，一定全部是贡献边。显然。 那么，怎么求这些边呢$($编号按字典序排并且要最少的边$)$？ 由于这些贡献边控制了流量，所以，我们把它删除掉，再流一遍，会得到一个新的$ans(ans$可能是0$)$，$ans+$这条边的权值$=$不删这条边的最大流，依靠这条等式，就可以去判断了，最后排序即可。]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>网络流</tag>
        <tag>最小割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.3.20模拟赛T4]]></title>
    <url>%2F2019%2F03%2F20%2F2019.3.20%E6%A8%A1%E6%8B%9F%E8%B5%9BT4%2F</url>
    <content type="text"><![CDATA[传送门 出题人：我本来就不想让你们拿分。。咳咳咳 果然没有拿到分。。自闭 设最大的能通过或运算得到的值为$ma$，则根据$a[i]$的范围，$0\leq ma&lt;(1&lt;&lt;17)$。不是很大，考虑枚举$ma$来求得答案。 设当前枚举$ma$枚举到$now$，我们要求出有多少对$(a,b)$满足$a|b=now$，$(a,b)$的对数大于$0$就说明这个$ma$是符合条件的。$(ma$倒着枚举，一满足条件就退出$)$ 怎么求出$(a,b)$的对数呢？考虑先枚举$a$，发现$a$在二进制下必然是$now$的子集，这里用到一个枚举二进制子集的套路： 假如要枚举$i$的二进制子集，套路代码如下：1for(int x=i;x;x=(x-1)&amp;i) 所有的$x$即为$i$的二进制子集，我也不知道为什么$($因为是套路$)$ 我们枚举出所有的$now$的二进制子集$a$，对于每一个$a$，$now-a$的超集都可以成为答案。当然超集中的数应该是读入的数中有的。 发现我们要预处理出超集，清楚了超集的概念应该很好预处理。对于每个$now$，它的子集的超集数量要加上等于$now$的数的个数。这些数的个数用一个桶记录。 还有一些细节，包括去重等，可见具体代码：1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;#define ll long long#define hh puts("")using namespace std;int n,t[500005],a[500005],x[500005],y[500005],ans1,ans2;inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-1;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;int main()&#123; n=read(); for(int i=1;i&lt;=n;i++)&#123; a[i]=read(); t[a[i]]++;//t[i]表示i出现的次数(桶) &#125; //下文中集合均为二进制下 for(int i=0;i&lt;(1&lt;&lt;17);i++)&#123; for(int j=i;j;j=(j-1)&amp;i) y[j]+=t[i]; y[0]+=t[i];//y[i]记录i的超集中有多少数字是可行的(也就是读入进来的) &#125; for(int i=(1&lt;&lt;17)-1;i&gt;=1;i--)&#123;//枚举最大值i,对于每个i计算方案数 int tmp=0; for(int j=i;j;j=(j-1)&amp;i) tmp+=t[j]*y[i-j]; //显然,对于一个可以与j进行或运算达到最大值i的数x,i-j是x的子集,所有的x的集合就是i-j的超集 tmp+=t[0]*y[i]; tmp-=t[i];//循环时,当j=i,y[i-j]多包含一次t[i],所以减掉 if(tmp)&#123; ans1=i; ans2=tmp/2; //(a,b)(b,a)的组合都算进去了,所以除以二 break; &#125; &#125; printf("%d %d",ans1,ans2); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>数论</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP2886 【[USACO07NOV]牛继电器Cow Relays】]]></title>
    <url>%2F2019%2F03%2F18%2F%E9%A2%98%E8%A7%A3%20luoguP2886%20%E3%80%90%5BUSACO07NOV%5D%E7%89%9B%E7%BB%A7%E7%94%B5%E5%99%A8Cow%20Relays%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 首先发现是一张连通图，而且只有$100$条边，那么点也很少 编号是乱的，先进行一波离散化，上$map$即可(STL大法好) 离散化后，转化成邻接矩阵，这个矩阵实际上表示的是$i$到$j$只经过$1$条边的最短路矩阵。这时发现，我们要求的答案是一个$st$到$ed$且只经过$n$条边的最短路矩阵。 考虑如何从小矩阵推向大矩阵：设矩阵$A$是一个任意两点经过$x$条边的最短路矩阵，设矩阵$B$是一个任意两点经过$y$条边的最短路矩阵 $A$ $\times$ $B$得到矩阵$C$，那么矩阵$C$是一个经过$(x+y)$条边的矩阵 重载乘法，因为矩阵转移时的实质为$Floyd$松弛：$C(i,j)=min(A(i,k)+B(k,j)) (1&lt;=k&lt;=n)$ 答案就是初始矩阵的$k$次方，矩阵快速幂加速即可1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define oo (1e18)#define int long long#define LL unsigned long long#define hh puts("")using namespace std;int k,m,st,ed,cnt=0;map&lt;int,int&gt; mp;struct matrix&#123; int ma[105][105]; void init()&#123;memset(ma,0x3f,sizeof(ma));&#125;&#125;f,ans;inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-1;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;matrix mul(matrix a,matrix b)&#123; matrix res; res.init(); for(int kk=1;kk&lt;=cnt;kk++) for(int i=1;i&lt;=cnt;i++) for(int j=1;j&lt;=cnt;j++) res.ma[i][j]=min(res.ma[i][j],a.ma[i][kk]+b.ma[kk][j]); return res;&#125;void ksm(int p)&#123; while(p)&#123; if(p&amp;1) ans=mul(ans,f); p&gt;&gt;=1; f=mul(f,f); &#125;&#125;signed main()&#123; k=read(),m=read(),st=read(),ed=read(); f.init(),ans.init(); for(int i=1;i&lt;=m;i++)&#123; int v=read(); int x=read(),y=read(); if(!mp[x]) mp[x]=++cnt; if(!mp[y]) mp[y]=++cnt; f.ma[mp[x]][mp[y]]=f.ma[mp[y]][mp[x]]=min(f.ma[mp[x]][mp[y]],v); &#125; for(int i=1;i&lt;=cnt;i++) ans.ma[i][i]=0; ksm(k); printf("%lld",ans.ma[mp[st]][mp[ed]]); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>最短路</tag>
        <tag>Luogu</tag>
        <tag>离散化</tag>
        <tag>Floyd</tag>
        <tag>矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[欧拉函数学习笔记]]></title>
    <url>%2F2019%2F03%2F17%2F%E6%AC%A7%E6%8B%89%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[定义：对于正整数$n$，欧拉函数是小于等于$n$的数中与$n$互质的数的个数。 符号：$φ(n)$表示$n$的欧拉函数，默认$φ(1)=1$。 一些定理： 1.对于一个素数$p$，$φ(p)=p-1$。 证明略。 2.对于两个互质的数$a,b$，$φ(a \times b)=φ(a) \times φ(b)$。$($感谢 $hyj$ 巨佬的指正$)$ 证明：因为$a$与$b$互质，所以$a$与$b$没有共同的质因数。设$a$有$k_a$个质因数，$b$有$k_b$个质因数，因此： \begin{aligned}φ(a)*φ(b)&=a*\prod\limits_{i=1}^{k_a} \left(1-\dfrac{1}{p[i]}\right)*b*\prod\limits_{i=1}^{k_b} \left(1-\dfrac{1}{p[i]}\right)\\&=a*b*\prod\limits_{i=1}^{k_a+k_b} \left(1-\dfrac{1}{p[i]}\right)\\&=φ(a*b)\end{aligned}注：欧拉函数是积性函数，但不是完全积性函数。 $update$：这个证法貌似是错的，因为要用到欧拉函数的公式，但是欧拉函数的公式又要由这个式子推出来。所以只能显然正确了。真的证明我还不会$($我菜爆了$)$，可以参考这里 3.对于一个素数$p$的幂次，如$p^{a}$，有$φ(p^{a})$ $=$ $(p-1)$ $\times$ $p^{a-1}$。 证明：比$p^{a}$小的正整数共$p^{a}-1$个。其中所有$p$的倍数可以表示成$p$ $\times$ $t$ $(t=1,2……p^{a-1}-1)$，即共有$p^{a-1}-1$个数能被$p$整除。因为$p$是质数，所以显然只有这些数不能被$p$整除，剩余的数都与$p$互质。因此，$φ(p^{a})$ $=$ $p^{a}-1$ $-$ $(p^{a-1}-1)$ $=$ $(p-1)$ $\times$ $p^{a-1}$。 4.如果$i\%p=0$，那么$φ(i\times p)=φ(i)\times p$。 证明：懒了不想写，好像没多大用。 求欧拉函数： 1.求单个欧拉函数：$φ(x)$ $=x$ $\times$ $\prod\limits_{i=1}^k \left(1-\dfrac{1}{p[i]}\right)$ 其中$p[1],p[2]……p[k]$为$x$的所有质因子 证明：首先，由整数的唯一分解定理可得，$x$ $=$ $p[1]^{a_1}$ $\times$ $p[2]^{a_2}$ $\times$ $……$ $\times$ $p[k]^{a_k}$。显然$p[1]^{a_1}$，$p[2]^{a_2}$，$……$，$p[k]^{a_k}$之间两两互质。那么，根据定理$2,3$： \begin{aligned}φ(x)&=φ(p[1]^{a_1})*φ(p[2]^{a_2})*......*φ(p[k]^{a_k})\\&=(p[1]^{a_1}*(1-\frac{1}{p[1]}))*(p[2]^{a_2}*(1-\frac{1}{p[2]}))*......* (p[k]^{a_k}*(1-\frac{1}{p[k]}))\\&=(p[1]^{a_1}*p[2]^{a_2}*......*p[k]^{a_k})*(1-\frac{1}{p[1]})*(1-\frac{1}{p[2]})*......*(1-\frac{1}{p[k]})\\&=x*\prod\limits_{i=1}^k \left(1-\dfrac{1}{p[i]}\right)\end{aligned}代码：1234567891011inline int getphi(int x)&#123; int res=x; for(int i=2;i*i&lt;=x;i++)&#123; if(x%i==0)&#123; res=res/i*(i-1);//通分公式大括号内内容即可 while(x%i==0) x/=i; &#125; &#125; if(x&gt;1) res=res/x*(x-1); return res;&#125; 2.线性筛欧拉函数：方法类似于筛素数，其实并不难，在筛素数的同时进行筛欧拉函数。 用到上面的1，2，4定理。 代码： 1234567891011121314for(int i=2;i&lt;=n;i++)&#123; if(!v[i])&#123; phi[i]=i-1; pr[++top]=i; &#125; for(int j=1;j&lt;=top&amp;&amp;i*pr[j]&lt;=n;j++)&#123; v[i*pr[j]]=1; if(i%pr[j]==0)&#123; phi[i*pr[j]]=phi[i]*pr[j]; break; &#125; else phi[i*pr[j]]=phi[i]*phi[pr[j]]; &#125;&#125; 欧拉定理：若$gcd(a,m)=1​$，那么$a^{φ(m)}​$ $\equiv​$ $1 \pmod m​$。 证明：找欧拉去]]></content>
      <tags>
        <tag>数论</tag>
        <tag>学习笔记</tag>
        <tag>欧拉函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP3320 【[SDOI2015]寻宝游戏】]]></title>
    <url>%2F2019%2F03%2F14%2F%E9%A2%98%E8%A7%A3%20luoguP3320%20%E3%80%90%5BSDOI2015%5D%E5%AF%BB%E5%AE%9D%E6%B8%B8%E6%88%8F%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 看到建虚树的做法？？？不会 这题要求每一次加减操作都计算答案，那么我们考虑加入一个点的贡献。 慢慢分析：首先一个点或者没有点，肯定没有贡献，为0。 然后是两个点，随便从一个点开始，走到另一个点再返回，贡献为2 $\times$ $dis(x,y)$。 回忆一下树上两点距离：$x$到$y$的距离$=$ $x$到根的距离$+$ $y$到根的距离$-$ $lca(x,y)$到根的距离$\times$ 2。($lca$想怎么求怎么求) 再增加一个点呢？树上有3个点，怎么走能使距离最短？应该是按遍历时的时间戳走咯。假设时间戳为1，2，3，那么贡献就是1-&gt;2 $+$ 2-&gt;3 $+$ 3-&gt;1。(箭头表示两点之间距离) 那么不管几个点，我们发现按时间戳走肯定最快。所以考虑维护加入点的时间戳。蒟蒻我不会$splay$，只能甩出一手$STL$大法$set$。(STL大法好) 每插入一个元素，考虑增加的贡献，是先删去它时间戳($set$里面)左边和右边的贡献，再加上它和左边以及它和右边的贡献。删去一个元素同理。这题做完，对$set$的使用以后就会很熟练了。 注意特判一个点的情况以及开$long\ long$。 上代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include&lt;bits/stdc++.h&gt;#define ts cout&lt;&lt;"ok"&lt;&lt;endl#define oo (1e18)#define int long long#define LL unsigned long long#define ite set&lt;int&gt;::iterator#define ls(x) (x&lt;&lt;1)#define rs(x) (x&lt;&lt;1|1)#define hh puts("")using namespace std;int n,m,cnt,head[100005],dfn[100005],bz[100005][20],dis[100005],vis[100005],dep[100005],ans;set&lt;int&gt; s;struct Edge&#123; int v,nx,s;&#125;e[200005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-1;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline void add(int x,int y,int z)&#123; e[++cnt].v=y; e[cnt].nx=head[x]; e[cnt].s=z; head[x]=cnt;&#125;void dfs(int now,int fa)&#123; dfn[now]=++cnt;//时间戳 vis[cnt]=now;//dfs序 dep[now]=dep[fa]+1; for(int i=head[now];i;i=e[i].nx)&#123; int v=e[i].v; if(v==fa) continue; dis[v]=dis[now]+e[i].s; bz[v][0]=now; dfs(v,now); &#125;&#125;inline ite lef(ite it)&#123; if(it==s.begin()) return --s.end(); return --it;&#125;inline ite rig(ite it)&#123; if(it==--s.end()) return s.begin(); return ++it;&#125;inline int LCA(int x,int y)&#123; if(dep[x]&lt;dep[y]) swap(x,y); for(int i=17;i&gt;=0;i--)&#123; if(dep[bz[x][i]]&gt;=dep[y]) x=bz[x][i]; &#125; if(x==y) return x; for(int i=17;i&gt;=0;i--) if(bz[x][i]!=bz[y][i]) x=bz[x][i],y=bz[y][i]; return bz[x][0];&#125;signed main()&#123; n=read(),m=read(); for(int i=1;i&lt;n;i++)&#123; int x=read(),y=read(),z=read(); add(x,y,z); add(y,x,z); &#125; cnt=0; dis[1]=0; dfs(1,0); for(int k=1;k&lt;=17;k++) for(int i=1;i&lt;=n;i++) bz[i][k]=bz[bz[i][k-1]][k-1]; for(int i=1;i&lt;=m;i++)&#123; int x=read(); if(!s.count(dfn[x]))&#123; if(s.size())&#123; ite it=s.lower_bound(dfn[x]); if(it==s.end()) it=s.begin(); ite L=lef(it); int lca1=LCA(vis[*it],vis[*L]); int lca2=LCA(vis[*it],x); int lca3=LCA(vis[*L],x); ans-=dis[vis[*it]]+dis[vis[*L]]-2*dis[lca1]; ans+=dis[vis[*it]]+dis[x]-2*dis[lca2]; ans+=dis[vis[*L]]+dis[x]-2*dis[lca3]; &#125; s.insert(dfn[x]); printf("%lld\n",ans); continue; &#125; else&#123; ite it=s.find(dfn[x]); ite L=lef(it),R=rig(it); int lca1=LCA(x,vis[*L]); int lca2=LCA(x,vis[*R]); int lca3=LCA(vis[*L],vis[*R]); ans-=dis[x]+dis[vis[*L]]-2*dis[lca1]; ans-=dis[x]+dis[vis[*R]]-2*dis[lca2]; ans+=dis[vis[*L]]+dis[vis[*R]]-2*dis[lca3]; s.erase(dfn[x]); printf("%lld\n",ans); continue; &#125; &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>LCA</tag>
        <tag>set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP2161 【[SHOI2009]会场预约】]]></title>
    <url>%2F2019%2F03%2F08%2F%E9%A2%98%E8%A7%A3%20luoguP2161%20%E3%80%90%5BSHOI2009%5D%E4%BC%9A%E5%9C%BA%E9%A2%84%E7%BA%A6%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 线段树好题 。转换题意。将操作看成染色：操作$A$，即统计一段区间内颜色的种类数，并将这个区间修改为同一个颜色。操作$B$，统计整颗线段树上还剩下多少种颜色。 考虑如何用线段树实现这一操作：对于操作$A$，明显就是一个查询$-&gt;$覆盖的操作。对于查询，考虑在修改时进行查询。我们用一个$col[k]$数组维护一段区间的颜色是否为同一个。若为同一个，我们覆盖掉，并使$delans$++$(delans$表示拒绝掉的预约数$)$，否则，分左右两段递归修改。答案即$delans$。 这时有一个问题：若一种颜色一段在修改的区间内，一段在修改的区间外，怎么处理？根据题意要求：对于新的预约操作，只要与先前预约有冲突，就全部拒绝掉。那就再设计一个$del$数组，记录一种颜色是否被删掉，就可以做到只要一种颜色有一段在区间内，就能保证它被全部删掉。 操作$B$相对简单很多，维护一个全局颜色数$ans$，每次$A$操作染色，显然先使$ans$++$($多一种颜色$)$，在染色时，每拒绝掉一个预约，$ans$- -即可。然后操作$B$就要求输出$ans$。 完结撒花~~ 哦对，线段树标配$tag$数组就代表该区间的颜色，$tag$为$0$时表示没有颜色，无需下传。下传时的细节：既然下传了，那么显然区间不是同色，$col[k]$赋为$0$。显然原因：下传操作的进行，是因为当前区间不完全在修改区间范围内$($否则就直接$change$并且$return$了$)$，那么当前区间一部分在修改区间范围内，一部分不在，显然不同色。代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;#define ll long long#define LL unsigned long long#define ls(x) x&lt;&lt;1#define rs(x) x&lt;&lt;1|1#define hh puts("")using namespace std;int n,col[400005],maxx,cnt,ans,del_cnt=0;int del[400005],tag[400005];struct Q&#123; int l,r,opt;&#125;q[200005];void build(int l,int r,int k)&#123; col[k]=1;//col[k]表示线段树中的k区间颜色都相同(把预约看成染色) if(l==r) return; int mid=(l+r)&gt;&gt;1; build(l,mid,ls(k)); build(mid+1,r,rs(k));&#125;void push_down(int l,int r,int k)&#123; col[k]=0; if(!tag[k]) return; tag[ls(k)]=tag[k]; tag[rs(k)]=tag[k]; tag[k]=0;&#125;void change(int l,int r,int v,int k)&#123; if(col[k])&#123; if(tag[k]&amp;&amp;!del[tag[k]])&#123; del_cnt++; ans--; &#125; del[tag[k]]=1; tag[k]=v; return; &#125; int mid=(l+r)&gt;&gt;1; change(l,mid,v,ls(k)); change(mid+1,r,v,rs(k)); col[k]=1,tag[k]=v;&#125;void update(int l,int r,int x,int y,int v,int k)&#123;//将x~y区间内所有颜色都变成v if(x&lt;=l&amp;&amp;r&lt;=y)&#123; change(l,r,v,k); return; &#125; push_down(l,r,k); int mid=(l+r)&gt;&gt;1; if(x&lt;=mid) update(l,mid,x,y,v,ls(k)); if(mid+1&lt;=y) update(mid+1,r,x,y,v,rs(k));&#125;signed main()&#123; scanf("%d",&amp;n); for(int i=1;i&lt;=n;i++)&#123; char rd[5]; scanf("%s",rd+1); if(rd[1]=='A')&#123; q[i].opt=1; scanf("%d%d",&amp;q[i].l,&amp;q[i].r); maxx=max(maxx,q[i].r); &#125; else q[i].opt=2; &#125; build(1,maxx,1); for(int i=1;i&lt;=n;i++)&#123; if(q[i].opt==1)&#123; ans++; del_cnt=0; update(1,maxx,q[i].l,q[i].r,++cnt,1); printf("%d\n",del_cnt); &#125; else printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 luoguP1772 【[ZJOI2006]物流运输】]]></title>
    <url>%2F2019%2F03%2F07%2F%E9%A2%98%E8%A7%A3%20luoguP1772%20%E3%80%90%5BZJOI2006%5D%E7%89%A9%E6%B5%81%E8%BF%90%E8%BE%93%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 模拟赛居然考了这道题，前一天刚看过，结果看了舍不得(不会)做，结果只骗到30pt 讲课人：很容易想到最短路+$dp$(我靠一点都不容易) 模拟赛后分析，才知道是处理出第i天到第j天都走同一条最短路的花费为$co[i][j]$ 然后进行$dp$，$dp[i]$表示前i天的最小花费 转移方程很好想:$dp[i]$ $=$ $min$ $($ $dp[j]$ $+$ $co[j+1][i]$ $\times$ $(i-j)$ $+$ $k$ $)$，预处理要赋值为$co[1][i]$ $\times$ $i$ $dp$方程的意思，即在第$j+1$天改变路线，第$j+1$天~第$i$天都走同一条路线 那么如何处理$co[i][j]$? 很简单，对于每一个$(i,j)$，先把$i$到$j$天之间封闭的码头全部设为不可走，跑一遍最短路即可，初值为无穷 数据辣么小，跑几遍以及跑什么都没关系嘤嘤嘤 那我们就十分愉♂快的解决了此题~~~ 愉♂快的提交了然后居然只有90pt 原谅我无耻的打开题解 啊啊啊原来要开$long$ $long$(明明数据辣么小) 献上代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;bits/stdc++.h&gt;#define soo (1e8)#define ll long longusing namespace std;int d,cnt,head[25],dis[25],vis[25],cant_vis[25];ll co[105][105],dp[105];int n,m,k,ee,cl[25][105];struct Edge&#123; int v,nx,s;&#125;e[10005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+ch-'0';ch=getchar();&#125; return ret*ff;&#125;void add(int x,int y,int z)&#123; e[++cnt].v=y; e[cnt].s=z; e[cnt].nx=head[x]; head[x]=cnt;&#125;void spfa()&#123;//爱跑什么跑什么 for(int i=1;i&lt;=m;i++) dis[i]=soo,vis[i]=0; queue&lt;int&gt; q; dis[1]=0; q.push(1); while(!q.empty())&#123; int x=q.front(); q.pop(); vis[x]=0; for(int i=head[x];i;i=e[i].nx)&#123; int v=e[i].v; if(cant_vis[v]) continue; if(dis[v]&gt;dis[x]+e[i].s)&#123; dis[v]=dis[x]+e[i].s; if(!vis[v])&#123; vis[v]=1; q.push(v); &#125; &#125; &#125; &#125;&#125;signed main()&#123; n=read(),m=read(),k=read(),ee=read(); for(int i=1;i&lt;=ee;i++)&#123; int x=read(),y=read(),z=read(); add(x,y,z); add(y,x,z); &#125; d=read(); for(int i=1;i&lt;=d;i++)&#123; int t=read(),x=read(),y=read(); for(int j=x;j&lt;=y;j++) cl[t][j]=1; &#125; //cl[i][j]表示第i个码头在第j天不能走 for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++)&#123; memset(cant_vis,0,sizeof(cant_vis)); for(int r=i;r&lt;=j;r++) for(int l=1;l&lt;=m;l++) if(cl[l][r]) cant_vis[l]=1; spfa(); co[i][j]=dis[m]; &#125; memset(dp,0x7f,sizeof(dp)); for(int i=1;i&lt;=n;i++)&#123; dp[i]=(ll)co[1][i]*i; for(int j=i-1;j&gt;=0;j--) dp[i]=min(dp[i],dp[j]+co[j+1][i]*(i-j)+k); &#125; printf("%lld",dp[n]); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>Luogu</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[题解 CF773D 【Perishable Roads】]]></title>
    <url>%2F2019%2F03%2F07%2F%E9%A2%98%E8%A7%A3%20CF773D%20%E3%80%90Perishable%20Roads%E3%80%91%2F</url>
    <content type="text"><![CDATA[传送门 简述一下题意：给出$n$个点的完全图，对于完全图中的每个点$i$，$i$作为终点时，要使其他每个点到点$i$的“距离”和最小，对于每个点都输出这个最小值。这里的“距离”是指对于其他每个点，那个点到点$i$路径上的最小值。且对于每个点$i$，计算答案时应保证图内每条边的方向一定。（有点难解释，可以参考原文） 题意很难表述清楚，建议看懂原题后再来看此题解。 考虑对于每个终点$i$，最后连接所有点后图的形态，应该是一棵树接上一条链。如图： 我会贪心&amp;&amp;搜索！从终点开始倒搜，对于当前搜到的点$now$，每次找到未$vis$的且与$now$相连的边权最小的点，向那个点继续搜。 很显然这个想法是非常非常错误的，直接排除 考虑优化贪心：既然让每个点到终点路径上的最小边权和最小，那么很容易想到将所有点都连到边权最小的边的一端，再从这个点连向终点。$($下文我们将这个点称为“最小点”$)$ 但这个还是错误的，如果连向终点的那条边权值特别大$(INF)$，那么答案就会非常劣。如图： 那怎么办呢？我们就考虑让“最小点”去间接的连向终点，即从那些直接连向“最小点”的点中取一些出来，与“最小点”构成一条链，使这一条链加上那棵树的答案更优。我们称这条链$($起点为最小点,终点为$t$ $)$的答案为$dis[t]$。如图： 怎么计算答案呢？我们设那条链上除终点外有$x$个点，那么那棵树上就有$n-1-x$个点，设最小边长度为$minn$，那么答案为$dis[t]$+$minn$ $\times$ $(n-1-x)$。 这个$x$很难计算，考虑消去。即计算$dis[t]$前先对所有边权减去一个$minn$，设新链答案为$dis’[t]$，那么答案会变成$($ $dis’[t]$+$minn$ $\times$ $x$ $)$+$minn$ $\times$ $(n-1-x)$，即$dis’[t]$+$minn$ $\times$ $(n-1)$，$x$就消去了。所以我们计算$dis’[t]$即可。 因为要求最优解，我们跑最短路求$dis$ $($定义见上$)$。一开始的状态是上面图2，即向终点直接连边，所以赋为终点与最小点的边权$($详见代码$)$。还有一种状态，即考虑那条链上有3个点。设加入的为点$j$，那么链的答案可能为最小点到终点的答案加上$j$到终点的答案，即$f[i][j]*2$ $($ $f$数组为邻接矩阵，$i$是终点 $)$。最后$dij$松弛即可$($模板$)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;bits/stdc++.h&gt;using namespace std;int n,f[3005][3005],vis[3005],dis[3005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-1;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;inline void write(int x)&#123; if(x&lt;0)&#123;putchar('-');x=-x;&#125; if(x&gt;9)write(x/10); putchar(x%10+48);&#125;void dij(int st)&#123; for(int i=1;i&lt;=n;i++)&#123; dis[i]=f[st][i]; for(int j=1;j&lt;=n;j++) if(i!=j) dis[i]=min(dis[i],f[i][j]*2); &#125; vis[st]=1; for(int i=1;i&lt;=n-1;i++)&#123; int minn=2e9+1,k; for(int j=1;j&lt;=n;j++) if(!vis[j]&amp;&amp;dis[j]&lt;minn)&#123; minn=dis[j]; k=j; &#125; vis[k]=1; for(int j=1;j&lt;=n;j++) if(!vis[j]) dis[j]=min(dis[j],dis[k]+f[j][k]); &#125;&#125;int main()&#123; int minn=2e9+1,k; n=read(); for(int i=1;i&lt;=n-1;i++) for(int j=1;j&lt;=n-i;j++)&#123; f[i][i+j]=f[i+j][i]=read(); if(f[i][i+j]&lt;minn)&#123; minn=f[i][i+j]; k=i; &#125; &#125; for(int i=1;i&lt;=n-1;i++) for(int j=1;j&lt;=n-i;j++)&#123; f[i][i+j]-=minn; f[i+j][i]=f[i][i+j]; &#125; dij(k); for(int i=1;i&lt;=n;i++) printf("%d ",dis[i]+minn*(n-1)); return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>最短路</tag>
        <tag>Codeforces</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.3.2模拟赛T2]]></title>
    <url>%2F2019%2F03%2F02%2F2019.3.2%E6%A8%A1%E6%8B%9F%E8%B5%9BT2%2F</url>
    <content type="text"><![CDATA[传送门 这是一道经典套路题。 ——讲课人同余最短路，第一次听说这种东西嘤嘤嘤，墨墨的等式那题也是一样 我学过语文！（丢人）题意一看就是让你求一个数能不能被若干个给你的数组合出来，考虑背包 我会背包！完全背包裸题啊是不是？ 我靠怎么询问这么大，背包它死了 我会套路！终于步入正轨 首先可以发现一个很简单的套路推论：取$a[i]$ $(1&lt;=i&lt;=n)$中的最小值为$mn$，如果$x$可以被构造出来，那么$x$ $+$ $mn$ $\times$ $k$也可以被构造出来。（正确性显然） 我们定义一个$dis[x]$ ($0$ $&lt;=$ $x$ $&lt;$ $mn$)为最小的能构造出的$x$ $+$ $mn$ $\times$ $k$ ($k&gt;=0$ 且 $k$为整数) 那么对于任何一个数$t$，只要$t$大于等于$dis[t$ $\%$ $mn]$，那么显然$t$可以被构造$($需要意会$)$ 然后我们的问题就是如何求$dis$数组了，哈哈哈名字都叫$dis$那肯定是最短路了 数据这么小那直接$SPFA$乱搞咯$($这种题卡不了$SPFA$的$)$ 首先$dis[0]=0$，即构造$0$不需要选任何东西，然后每次从队列中取出一个去松弛其他点。设当前取出的为$x$，枚举每个$a[i]$去松弛$dis[(x+a[i])$ $\%$ $mn]$，其他都是常规写法 至此我们解决完了，上代码：$($超级短好不好$)$1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;bits/stdc++.h&gt;#define ll long long#define soo (1e9)#define oo (1e18)using namespace std;int n,a[5005],m,mo,vis[50005],dis[50005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-1;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+(ch^48);ch=getchar();&#125; return ret*ff;&#125;void spfa()&#123; memset(dis,0x3f,sizeof(dis)); queue&lt;int&gt;q; dis[0]=0; q.push(0); while(!q.empty())&#123; int x=q.front(); q.pop(); vis[x]=0; for(int i=0;i&lt;n;i++)&#123; if(dis[(x+a[i])%mo]&gt;dis[x]+a[i])&#123; dis[(x+a[i])%mo]=dis[x]+a[i]; if(!vis[(x+a[i])%mo])&#123; vis[(x+a[i])%mo]=1; q.push((x+a[i])%mo); &#125; &#125; &#125; &#125;&#125;signed main()&#123; n=read(); for(int i=0;i&lt;n;i++) a[i]=read(); sort(a,a+n); mo=a[0]; spfa(); m=read(); for(int i=1;i&lt;=m;i++)&#123; int qu=read(); if(qu&lt;dis[qu%mo]) puts("NIE"); else puts("TAK"); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>题解</tag>
        <tag>模拟赛</tag>
        <tag>最短路</tag>
        <tag>同余</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分块学习笔记]]></title>
    <url>%2F2019%2F02%2F17%2F%E5%88%86%E5%9D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[看到$cr$奆佬一天就学会了分块，甚至看着题解$A$掉了$YNOI$的毒瘤分块题，我也来入坑了哈哈哈哈哈。$($本文总结了巨多别人的博客$)$ 分块是一个很暴力的算法！咳咳先不提这个。。。 啥是分块：分块是一个很暴力的算法。分块将所有数据分为若干个块，维护块内信息，使得块内的查询是$O(1)$的，而总的询问就可以看做若干个块询问的总和。一般来讲，块的大小常设为$sqrt(n)$，但实际上块的大小可以任意自定，通过调试来尽可能让复杂度更优。 偷图： 为什么要分块：因为。。。分块是一个很暴力的算法。它可以完成几乎所有区间更新和区间查询问题$($考场骗分利器$)$。对于小数据，可能效率与线段树相似。虽然大数据可能效率较低，但有些题的确只能用分块做$($神仙不管$)$。总之，分块的适用性比线段树要广，毕竟是暴力算法 分块实现的基本框架： 划分块，预处理，操作或查询。 操作或查询通常为4步：1.判断要操作或是查询的区间是否在一个块内 2.若在一个块内，暴力操作或查询 3.若不在一个块内，将除了最左边和最右边这两个块外其余的块进行整体的操作，即直接对块打上修改标记之类的 4.单独暴力处理最左边的块和最右边的块 分块的基础即建块，类比线段树建树。用$size$表示每一块的大小，$num$表示一共几块，$belong[i]$表示原序列中第$i$个元素在第几块，$l[i],r[i]$分别表示第$i$块的左端点和右端点。上代码：1234567891011void build()&#123; size=sqrt(n); num=n/size; if(n%size!=0) num++;//除不尽说明多出一块边角料 for(int i=1;i&lt;=n;i++) belong[i]=(i-1)/size+1; for(int i=1;i&lt;=num;i++)&#123; l[i]=(i-1)*size+1; r[i]=i*size; &#125; r[num]=n;//最后一块大小可能不为size,右边界特殊处理 &#125; 来一道基础题：给出一个长为$n$的数列，以及$n$个操作，操作涉及区间加法，单点查值。$(1\leq n\leq 50000)$ 链接 这种题当然可以各种姿势水过去，但我们要学习分块，所以就分块咯。123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;bits/stdc++.h&gt;using namespace std;int n,size,num,belong[100005],l[10005],r[10005],tag[10005],w[100005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+ch-'0';ch=getchar();&#125; return ret*ff;&#125;void build()&#123; size=sqrt(n); num=n/size; if(n%size!=0) num++; for(int i=1;i&lt;=n;i++) belong[i]=(i-1)/size+1; for(int i=1;i&lt;=num;i++)&#123; l[i]=(i-1)*size+1; r[i]=i*size; &#125; r[num]=n; &#125;void add(int x,int y,int v)&#123; for(int i=x;i&lt;=min(y,r[belong[x]]);i++) w[i]+=v;//左边边角块 if(belong[x]!=belong[y])&#123;//不在同一个块 for(int i=(belong[y]-1)*size+1;i&lt;=y;i++)//右边边角块 w[i]+=v; &#125; for(int i=belong[x]+1;i&lt;=belong[y]-1;i++) tag[i]+=v;//块整体打标记&#125;int query(int x)&#123; return w[x]+tag[belong[x]];&#125;signed main()&#123; n=read(); for(int i=1;i&lt;=n;i++) w[i]=read(); build(); for(int i=1;i&lt;=n;i++)&#123; int opt=read(),x=read(),y=read(),v=read(); if(opt==0) add(x,y,v); else printf("%d\n",query(y)); &#125; return 0;&#125; 分块也可以水数据小的线段树，rt1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#pragma GCC optimize(3)#include&lt;bits/stdc++.h&gt;#define int long longusing namespace std;int n,m,size,num,belong[100005],l[10005],r[10005],sum[10005],tag[10005],w[100005];inline int read()&#123; int ret=0,ff=1;char ch=getchar(); while(!isdigit(ch))&#123;if(ch=='-') ff=-ff;ch=getchar();&#125; while(isdigit(ch))&#123;ret=(ret&lt;&lt;3)+(ret&lt;&lt;1)+ch-'0';ch=getchar();&#125; return ret*ff;&#125;void build()&#123; size=sqrt(n); num=n/size; if(n%size!=0) num++;//除不尽说明多出一块边角料 for(int i=1;i&lt;=n;i++) belong[i]=(i-1)/size+1; for(int i=1;i&lt;=num;i++)&#123; l[i]=(i-1)*size+1; r[i]=i*size; &#125; r[num]=n;//最后一块大小可能不为size,右边界特殊处理 &#125;void add(int x,int y,int v)&#123; for(int i=x;i&lt;=min(y,r[belong[x]]);i++) w[i]+=v;//左边边角块 sum[belong[x]]+=(min(y,r[belong[x]])-x+1)*v; if(belong[x]!=belong[y])&#123;//不在同一个块 for(int i=(belong[y]-1)*size+1;i&lt;=y;i++) w[i]+=v; sum[belong[y]]+=(y-((belong[y]-1)*size+1)+1)*v; &#125; for(int i=belong[x]+1;i&lt;=belong[y]-1;i++) tag[i]+=v,sum[i]+=v*size;&#125;int query(int x,int y)&#123; int res=0; for(int i=x;i&lt;=min(y,r[belong[x]]);i++) res+=w[i]+tag[belong[x]]; if(belong[x]!=belong[y])&#123; for(int i=(belong[y]-1)*size+1;i&lt;=y;i++) res+=w[i]+tag[belong[y]]; &#125; for(int i=belong[x]+1;i&lt;=belong[y]-1;i++) res+=sum[i]; return res;&#125;signed main()&#123; n=read(),m=read(); for(int i=1;i&lt;=n;i++) w[i]=read(); build(); for(int i=1;i&lt;=n;i++) sum[belong[i]]+=w[i]; for(int i=1;i&lt;=m;i++)&#123; int opt=read(),x=read(),y=read(); if(opt==1)&#123; int v=read(); add(x,y,v); &#125; else printf("%d\n",query(x,y)); &#125; return 0;&#125; 持续更新ing]]></content>
      <tags>
        <tag>学习笔记</tag>
        <tag>分块</tag>
      </tags>
  </entry>
</search>
